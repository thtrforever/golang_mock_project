// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: flights.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const createFlight = `-- name: CreateFlight :one
INSERT INTO flights(
	origin_airport_code, 
    destination_airport_code, 
    departure_date_time, 
    booking_class,
    flight_number,
    flight_duration,
    enabled, 
    seat_available, 
    currency_code, 
    price, 
    create_by, 
    create_date
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING id, origin_airport_code, destination_airport_code, departure_date_time, booking_class, flight_number, flight_duration, enabled, seat_available, currency_code, price, create_by, create_date, modify_by, modify_date
`

type CreateFlightParams struct {
	OriginAirportCode      string         `json:"origin_airport_code"`
	DestinationAirportCode string         `json:"destination_airport_code"`
	DepartureDateTime      time.Time      `json:"departure_date_time"`
	BookingClass           string         `json:"booking_class"`
	FlightNumber           string         `json:"flight_number"`
	FlightDuration         int32          `json:"flight_duration"`
	Enabled                bool           `json:"enabled"`
	SeatAvailable          int32          `json:"seat_available"`
	CurrencyCode           string         `json:"currency_code"`
	Price                  float64        `json:"price"`
	CreateBy               sql.NullString `json:"create_by"`
	CreateDate             sql.NullTime   `json:"create_date"`
}

func (q *Queries) CreateFlight(ctx context.Context, arg CreateFlightParams) (Flight, error) {
	row := q.db.QueryRowContext(ctx, createFlight,
		arg.OriginAirportCode,
		arg.DestinationAirportCode,
		arg.DepartureDateTime,
		arg.BookingClass,
		arg.FlightNumber,
		arg.FlightDuration,
		arg.Enabled,
		arg.SeatAvailable,
		arg.CurrencyCode,
		arg.Price,
		arg.CreateBy,
		arg.CreateDate,
	)
	var i Flight
	err := row.Scan(
		&i.ID,
		&i.OriginAirportCode,
		&i.DestinationAirportCode,
		&i.DepartureDateTime,
		&i.BookingClass,
		&i.FlightNumber,
		&i.FlightDuration,
		&i.Enabled,
		&i.SeatAvailable,
		&i.CurrencyCode,
		&i.Price,
		&i.CreateBy,
		&i.CreateDate,
		&i.ModifyBy,
		&i.ModifyDate,
	)
	return i, err
}

const deleteFlight = `-- name: DeleteFlight :exec
DELETE FROM flights
WHERE
    id=$1
`

func (q *Queries) DeleteFlight(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteFlight, id)
	return err
}

const getAvailableFlightsByFields = `-- name: GetAvailableFlightsByFields :many
SELECT id, origin_airport_code, destination_airport_code, departure_date_time, booking_class, flight_number, flight_duration, enabled, seat_available, currency_code, price, create_by, create_date, modify_by, modify_date FROM flights
WHERE 
    enabled='1'
    AND seat_available>0
    AND origin_airport_code=$3
    AND destination_airport_code=$4
    AND date_trunc('day', departure_date_time)<=$5
    AND (date_trunc('day', departure_date_time) + interval '1 day' - interval '1 second')>=$5
    AND (flight_number=$6 OR $6='')
    AND (booking_class=ANY($7::varchar[]) OR array_length($7::varchar[], 1) IS NULL)
ORDER BY 
    origin_airport_code ASC,
    destination_airport_code ASC,
    flight_number ASC,
    departure_date_time ASC
LIMIT $1
OFFSET $2
`

type GetAvailableFlightsByFieldsParams struct {
	Limit                  int32     `json:"limit"`
	Offset                 int32     `json:"offset"`
	OriginAirportCode      string    `json:"origin_airport_code"`
	DestinationAirportCode string    `json:"destination_airport_code"`
	DepartureDateTime      time.Time `json:"departure_date_time"`
	FlightNumber           string    `json:"flight_number"`
	BookingClasses         []string  `json:"BookingClasses"`
}

func (q *Queries) GetAvailableFlightsByFields(ctx context.Context, arg GetAvailableFlightsByFieldsParams) ([]Flight, error) {
	rows, err := q.db.QueryContext(ctx, getAvailableFlightsByFields,
		arg.Limit,
		arg.Offset,
		arg.OriginAirportCode,
		arg.DestinationAirportCode,
		arg.DepartureDateTime,
		arg.FlightNumber,
		pq.Array(arg.BookingClasses),
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Flight{}
	for rows.Next() {
		var i Flight
		if err := rows.Scan(
			&i.ID,
			&i.OriginAirportCode,
			&i.DestinationAirportCode,
			&i.DepartureDateTime,
			&i.BookingClass,
			&i.FlightNumber,
			&i.FlightDuration,
			&i.Enabled,
			&i.SeatAvailable,
			&i.CurrencyCode,
			&i.Price,
			&i.CreateBy,
			&i.CreateDate,
			&i.ModifyBy,
			&i.ModifyDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlightById = `-- name: GetFlightById :one
SELECT id, origin_airport_code, destination_airport_code, departure_date_time, booking_class, flight_number, flight_duration, enabled, seat_available, currency_code, price, create_by, create_date, modify_by, modify_date FROM flights
WHERE 
    id=$1
`

func (q *Queries) GetFlightById(ctx context.Context, id int64) (Flight, error) {
	row := q.db.QueryRowContext(ctx, getFlightById, id)
	var i Flight
	err := row.Scan(
		&i.ID,
		&i.OriginAirportCode,
		&i.DestinationAirportCode,
		&i.DepartureDateTime,
		&i.BookingClass,
		&i.FlightNumber,
		&i.FlightDuration,
		&i.Enabled,
		&i.SeatAvailable,
		&i.CurrencyCode,
		&i.Price,
		&i.CreateBy,
		&i.CreateDate,
		&i.ModifyBy,
		&i.ModifyDate,
	)
	return i, err
}

const getFlightsByFields = `-- name: GetFlightsByFields :many
SELECT id, origin_airport_code, destination_airport_code, departure_date_time, booking_class, flight_number, flight_duration, enabled, seat_available, currency_code, price, create_by, create_date, modify_by, modify_date FROM flights
WHERE 
    origin_airport_code=$3
    AND destination_airport_code=$4
    AND date_trunc('day', departure_date_time)<=$5
    AND (date_trunc('day', departure_date_time) + interval '1 day' - interval '1 second')>=$5
    AND flight_number=$6
    AND booking_class=$7
    AND seat_available>0
ORDER BY 
    origin_airport_code ASC,
    destination_airport_code ASC,
    departure_date_time ASC
LIMIT $1
OFFSET $2
`

type GetFlightsByFieldsParams struct {
	Limit                  int32     `json:"limit"`
	Offset                 int32     `json:"offset"`
	OriginAirportCode      string    `json:"origin_airport_code"`
	DestinationAirportCode string    `json:"destination_airport_code"`
	DepartureDateTime      time.Time `json:"departure_date_time"`
	FlightNumber           string    `json:"flight_number"`
	BookingClass           string    `json:"booking_class"`
}

func (q *Queries) GetFlightsByFields(ctx context.Context, arg GetFlightsByFieldsParams) ([]Flight, error) {
	rows, err := q.db.QueryContext(ctx, getFlightsByFields,
		arg.Limit,
		arg.Offset,
		arg.OriginAirportCode,
		arg.DestinationAirportCode,
		arg.DepartureDateTime,
		arg.FlightNumber,
		arg.BookingClass,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Flight{}
	for rows.Next() {
		var i Flight
		if err := rows.Scan(
			&i.ID,
			&i.OriginAirportCode,
			&i.DestinationAirportCode,
			&i.DepartureDateTime,
			&i.BookingClass,
			&i.FlightNumber,
			&i.FlightDuration,
			&i.Enabled,
			&i.SeatAvailable,
			&i.CurrencyCode,
			&i.Price,
			&i.CreateBy,
			&i.CreateDate,
			&i.ModifyBy,
			&i.ModifyDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFlight = `-- name: UpdateFlight :one
UPDATE flights
SET 
    origin_airport_code=$2,
    destination_airport_code=$3,
    departure_date_time=$4, 
    booking_class=$5, 
    flight_number=$6,
    flight_duration=$7, 
    enabled=$8, 
    seat_available=$9, 
    currency_code=$10, 
    price=$11, 
    modify_by=$12, 
    modify_date=$13
WHERE 
    id=$1
RETURNING id, origin_airport_code, destination_airport_code, departure_date_time, booking_class, flight_number, flight_duration, enabled, seat_available, currency_code, price, create_by, create_date, modify_by, modify_date
`

type UpdateFlightParams struct {
	ID                     int64          `json:"id"`
	OriginAirportCode      string         `json:"origin_airport_code"`
	DestinationAirportCode string         `json:"destination_airport_code"`
	DepartureDateTime      time.Time      `json:"departure_date_time"`
	BookingClass           string         `json:"booking_class"`
	FlightNumber           string         `json:"flight_number"`
	FlightDuration         int32          `json:"flight_duration"`
	Enabled                bool           `json:"enabled"`
	SeatAvailable          int32          `json:"seat_available"`
	CurrencyCode           string         `json:"currency_code"`
	Price                  float64        `json:"price"`
	ModifyBy               sql.NullString `json:"modify_by"`
	ModifyDate             sql.NullTime   `json:"modify_date"`
}

func (q *Queries) UpdateFlight(ctx context.Context, arg UpdateFlightParams) (Flight, error) {
	row := q.db.QueryRowContext(ctx, updateFlight,
		arg.ID,
		arg.OriginAirportCode,
		arg.DestinationAirportCode,
		arg.DepartureDateTime,
		arg.BookingClass,
		arg.FlightNumber,
		arg.FlightDuration,
		arg.Enabled,
		arg.SeatAvailable,
		arg.CurrencyCode,
		arg.Price,
		arg.ModifyBy,
		arg.ModifyDate,
	)
	var i Flight
	err := row.Scan(
		&i.ID,
		&i.OriginAirportCode,
		&i.DestinationAirportCode,
		&i.DepartureDateTime,
		&i.BookingClass,
		&i.FlightNumber,
		&i.FlightDuration,
		&i.Enabled,
		&i.SeatAvailable,
		&i.CurrencyCode,
		&i.Price,
		&i.CreateBy,
		&i.CreateDate,
		&i.ModifyBy,
		&i.ModifyDate,
	)
	return i, err
}

const updateFlightSeatAvailable = `-- name: UpdateFlightSeatAvailable :one
UPDATE flights
SET 
    seat_available=$2, 
    modify_by=$3, 
    modify_date=$4
WHERE 
    id=$1
RETURNING id, origin_airport_code, destination_airport_code, departure_date_time, booking_class, flight_number, flight_duration, enabled, seat_available, currency_code, price, create_by, create_date, modify_by, modify_date
`

type UpdateFlightSeatAvailableParams struct {
	ID            int64          `json:"id"`
	SeatAvailable int32          `json:"seat_available"`
	ModifyBy      sql.NullString `json:"modify_by"`
	ModifyDate    sql.NullTime   `json:"modify_date"`
}

func (q *Queries) UpdateFlightSeatAvailable(ctx context.Context, arg UpdateFlightSeatAvailableParams) (Flight, error) {
	row := q.db.QueryRowContext(ctx, updateFlightSeatAvailable,
		arg.ID,
		arg.SeatAvailable,
		arg.ModifyBy,
		arg.ModifyDate,
	)
	var i Flight
	err := row.Scan(
		&i.ID,
		&i.OriginAirportCode,
		&i.DestinationAirportCode,
		&i.DepartureDateTime,
		&i.BookingClass,
		&i.FlightNumber,
		&i.FlightDuration,
		&i.Enabled,
		&i.SeatAvailable,
		&i.CurrencyCode,
		&i.Price,
		&i.CreateBy,
		&i.CreateDate,
		&i.ModifyBy,
		&i.ModifyDate,
	)
	return i, err
}
